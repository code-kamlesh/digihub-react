{"ast":null,"code":"/**\r\n * Module convert fs functions to promise based functions\r\n */\nimport fs from 'node:fs';\nexport const pathExists = fs.existsSync;\nexport const createReadStream = fs.createReadStream;\nexport async function stat(path) {\n  return new Promise((resolve, reject) => {\n    fs.stat(path, (err, stats) => {\n      if (err) reject(err);else resolve(stats);\n    });\n  });\n}\nexport async function close(fd) {\n  return new Promise((resolve, reject) => {\n    fs.close(fd, err => {\n      if (err) reject(err);else resolve();\n    });\n  });\n}\nexport async function open(path, mode) {\n  return new Promise((resolve, reject) => {\n    fs.open(path, mode, (err, fd) => {\n      if (err) reject(err);else resolve(fd);\n    });\n  });\n}\nexport async function read(fd, buffer, offset, length, position) {\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {\n      if (err) reject(err);else resolve({\n        bytesRead,\n        buffer: _buffer\n      });\n    });\n  });\n}\nexport async function writeFile(path, data) {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(path, data, err => {\n      if (err) reject(err);else resolve();\n    });\n  });\n}\nexport function writeFileSync(path, data) {\n  fs.writeFileSync(path, data);\n}\nexport async function readFile(path) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(path, (err, buffer) => {\n      if (err) reject(err);else resolve(buffer);\n    });\n  });\n}","map":{"version":3,"sources":["D:/Tata_Strive/WebApplication/digiHub/trunk/digiHubWeb/node_modules/strtok3/lib/FsPromise.js"],"names":["fs","pathExists","existsSync","createReadStream","stat","path","Promise","resolve","reject","err","stats","close","fd","open","mode","read","buffer","offset","length","position","bytesRead","_buffer","writeFile","data","writeFileSync","readFile"],"mappings":"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","sourcesContent":["/**\r\n * Module convert fs functions to promise based functions\r\n */\r\nimport fs from 'node:fs';\r\nexport const pathExists = fs.existsSync;\r\nexport const createReadStream = fs.createReadStream;\r\nexport async function stat(path) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.stat(path, (err, stats) => {\r\n            if (err)\r\n                reject(err);\r\n            else\r\n                resolve(stats);\r\n        });\r\n    });\r\n}\r\nexport async function close(fd) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.close(fd, err => {\r\n            if (err)\r\n                reject(err);\r\n            else\r\n                resolve();\r\n        });\r\n    });\r\n}\r\nexport async function open(path, mode) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.open(path, mode, (err, fd) => {\r\n            if (err)\r\n                reject(err);\r\n            else\r\n                resolve(fd);\r\n        });\r\n    });\r\n}\r\nexport async function read(fd, buffer, offset, length, position) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {\r\n            if (err)\r\n                reject(err);\r\n            else\r\n                resolve({ bytesRead, buffer: _buffer });\r\n        });\r\n    });\r\n}\r\nexport async function writeFile(path, data) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.writeFile(path, data, err => {\r\n            if (err)\r\n                reject(err);\r\n            else\r\n                resolve();\r\n        });\r\n    });\r\n}\r\nexport function writeFileSync(path, data) {\r\n    fs.writeFileSync(path, data);\r\n}\r\nexport async function readFile(path) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.readFile(path, (err, buffer) => {\r\n            if (err)\r\n                reject(err);\r\n            else\r\n                resolve(buffer);\r\n        });\r\n    });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}