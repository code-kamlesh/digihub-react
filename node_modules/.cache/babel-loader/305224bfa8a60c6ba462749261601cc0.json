{"ast":null,"code":"import parseCellValue from './parseCellValue';\nimport { parseCellCoordinates } from './coordinates';\nimport { getCellValue, getCellInlineStringValue } from '../xml/xlsx'; // Example of a `<c/>`ell element:\n//\n// <c>\n//    <f>string</f> — formula.\n//    <v>string</v> — formula pre-computed value.\n//    <is>\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\n//       <r>\n//          <rPr>\n//            ...\n//          </rPr>\n//          <t>string</t>\n//       </r>\n//       <rPh sb=\"1\" eb=\"1\">\n//          <t>string</t>\n//       </rPh>\n//       <phoneticPr fontId=\"1\"/>\n//    </is>\n//    <extLst>\n//       <ext>\n//          <!--any element-->\n//       </ext>\n//    </extLst>\n// </c>\n//\n\nexport default function parseCell(node, sheet, xml, values, styles, properties, options) {\n  var coords = parseCellCoordinates(node.getAttribute('r'));\n  var valueElement = getCellValue(sheet, node); // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\n\n  var value = valueElement && valueElement.textContent;\n  var type;\n\n  if (node.hasAttribute('t')) {\n    type = node.getAttribute('t');\n  }\n\n  return {\n    row: coords[0],\n    column: coords[1],\n    value: parseCellValue(value, type, {\n      getInlineStringValue: function getInlineStringValue() {\n        return getCellInlineStringValue(sheet, node);\n      },\n      getStyleId: function getStyleId() {\n        return node.getAttribute('s');\n      },\n      styles: styles,\n      values: values,\n      properties: properties,\n      options: options\n    })\n  };\n}","map":{"version":3,"sources":["../../source/read/parseCell.js"],"names":["coords","parseCellCoordinates","node","valueElement","getCellValue","value","type","row","column","parseCellValue","getInlineStringValue","getCellInlineStringValue","getStyleId","styles","values","properties","options"],"mappings":"AAAA,OAAA,cAAA,MAAA,kBAAA;AAEA,SAAA,oBAAA,QAAA,eAAA;AAIA,SAAA,YAAA,EAAA,wBAAA,QAAA,aAAA,C,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAAA,SAAA,CAAA,IAAA,EAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,MAAA,EAAA,UAAA,EAAA,OAAA,EAA0E;AACvF,MAAMA,MAAM,GAAGC,oBAAoB,CAACC,IAAI,CAAJA,YAAAA,CAApC,GAAoCA,CAAD,CAAnC;AAEA,MAAMC,YAAY,GAAGC,YAAY,CAAA,KAAA,EAHsD,IAGtD,CAAjC,CAHuF,CAKvF;AACA;AACA;;AACA,MAAIC,KAAK,GAAGF,YAAY,IAAIA,YAAY,CAAxC,WAAA;AAEA,MAAA,IAAA;;AACA,MAAID,IAAI,CAAJA,YAAAA,CAAJ,GAAIA,CAAJ,EAA4B;AAC1BI,IAAAA,IAAI,GAAGJ,IAAI,CAAJA,YAAAA,CAAPI,GAAOJ,CAAPI;AACD;;AAED,SAAO;AACLC,IAAAA,GAAG,EAAEP,MAAM,CADN,CACM,CADN;AAELQ,IAAAA,MAAM,EAAER,MAAM,CAFT,CAES,CAFT;AAGLK,IAAAA,KAAK,EAAEI,cAAc,CAAA,KAAA,EAAA,IAAA,EAAc;AACjCC,MAAAA,oBAAoB,EAAE,SAAA,oBAAA,GAAA;AAAA,eAAMC,wBAAwB,CAAA,KAAA,EAA9B,IAA8B,CAA9B;AADW,OAAA;AAEjCC,MAAAA,UAAU,EAAE,SAAA,UAAA,GAAA;AAAA,eAAMV,IAAI,CAAJA,YAAAA,CAAN,GAAMA,CAAN;AAFqB,OAAA;AAGjCW,MAAAA,MAAM,EAH2B,MAAA;AAIjCC,MAAAA,MAAM,EAJ2B,MAAA;AAKjCC,MAAAA,UAAU,EALuB,UAAA;AAMjCC,MAAAA,OAAO,EAAPA;AANiC,KAAd;AAHhB,GAAP;AAYD","sourcesContent":["import parseCellValue from './parseCellValue'\r\n\r\nimport {\r\n  parseCellCoordinates\r\n} from './coordinates'\r\n\r\nimport {\r\n  getCellValue,\r\n  getCellInlineStringValue\r\n} from '../xml/xlsx'\r\n\r\n// Example of a `<c/>`ell element:\r\n//\r\n// <c>\r\n//    <f>string</f> — formula.\r\n//    <v>string</v> — formula pre-computed value.\r\n//    <is>\r\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\r\n//       <r>\r\n//          <rPr>\r\n//            ...\r\n//          </rPr>\r\n//          <t>string</t>\r\n//       </r>\r\n//       <rPh sb=\"1\" eb=\"1\">\r\n//          <t>string</t>\r\n//       </rPh>\r\n//       <phoneticPr fontId=\"1\"/>\r\n//    </is>\r\n//    <extLst>\r\n//       <ext>\r\n//          <!--any element-->\r\n//       </ext>\r\n//    </extLst>\r\n// </c>\r\n//\r\nexport default function parseCell(node, sheet, xml, values, styles, properties, options) {\r\n  const coords = parseCellCoordinates(node.getAttribute('r'))\r\n\r\n  const valueElement = getCellValue(sheet, node)\r\n\r\n  // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\r\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\r\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\r\n  let value = valueElement && valueElement.textContent\r\n\r\n  let type\r\n  if (node.hasAttribute('t')) {\r\n    type = node.getAttribute('t')\r\n  }\r\n\r\n  return {\r\n    row: coords[0],\r\n    column: coords[1],\r\n    value: parseCellValue(value, type, {\r\n      getInlineStringValue: () => getCellInlineStringValue(sheet, node),\r\n      getStyleId: () => node.getAttribute('s'),\r\n      styles,\r\n      values,\r\n      properties,\r\n      options\r\n    })\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}