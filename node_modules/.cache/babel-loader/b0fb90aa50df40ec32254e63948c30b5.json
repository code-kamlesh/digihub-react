{"ast":null,"code":"// Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\nvar LETTERS = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\nexport function calculateDimensions(cells) {\n  var comparator = function comparator(a, b) {\n    return a - b;\n  };\n\n  var allRows = cells.map(function (cell) {\n    return cell.row;\n  }).sort(comparator);\n  var allCols = cells.map(function (cell) {\n    return cell.column;\n  }).sort(comparator);\n  var minRow = allRows[0];\n  var maxRow = allRows[allRows.length - 1];\n  var minCol = allCols[0];\n  var maxCol = allCols[allCols.length - 1];\n  return [{\n    row: minRow,\n    column: minCol\n  }, {\n    row: maxRow,\n    column: maxCol\n  }];\n}\n\nfunction columnLettersToNumber(columnLetters) {\n  // `for ... of ...` would require Babel polyfill for iterating a string.\n  var n = 0;\n  var i = 0;\n\n  while (i < columnLetters.length) {\n    n *= 26;\n    n += LETTERS.indexOf(columnLetters[i]);\n    i++;\n  }\n\n  return n;\n}\n\nexport function parseCellCoordinates(coords) {\n  // Examples: \"AA2091\", \"R988\", \"B1\"\n  coords = coords.split(/(\\d+)/);\n  return [// Row.\n  parseInt(coords[1]), // Column.\n  columnLettersToNumber(coords[0].trim())];\n}","map":{"version":3,"sources":["../../source/read/coordinates.js"],"names":["LETTERS","comparator","a","allRows","cell","allCols","minRow","maxRow","minCol","maxCol","row","column","n","i","columnLetters","coords","parseInt","columnLettersToNumber"],"mappings":"AAAA;AACA,IAAMA,OAAO,GAAG,CAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAhB,GAAgB,CAAhB;AAEA,OAAO,SAAA,mBAAA,CAAA,KAAA,EAAqC;AAC1C,MAAMC,UAAU,GAAG,SAAbA,UAAa,CAAA,CAAA,EAAA,CAAA,EAAA;AAAA,WAAUC,CAAC,GAAX,CAAA;AAAnB,GAAA;;AACA,MAAMC,OAAO,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAI;AAAA,WAAIC,IAAI,CAAR,GAAA;AAAd,GAAA,EAAA,IAAA,CAAhB,UAAgB,CAAhB;AACA,MAAMC,OAAO,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAI;AAAA,WAAID,IAAI,CAAR,MAAA;AAAd,GAAA,EAAA,IAAA,CAAhB,UAAgB,CAAhB;AACA,MAAME,MAAM,GAAGH,OAAO,CAAtB,CAAsB,CAAtB;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAAvB,CAAsB,CAAtB;AACA,MAAMK,MAAM,GAAGH,OAAO,CAAtB,CAAsB,CAAtB;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAAvB,CAAsB,CAAtB;AAEA,SAAO,CACL;AAAEK,IAAAA,GAAG,EAAL,MAAA;AAAeC,IAAAA,MAAM,EAAEH;AAAvB,GADK,EAEL;AAAEE,IAAAA,GAAG,EAAL,MAAA;AAAeC,IAAAA,MAAM,EAAEF;AAAvB,GAFK,CAAP;AAID;;AAED,SAAA,qBAAA,CAAA,aAAA,EAA8C;AAC5C;AACA,MAAIG,CAAC,GAAL,CAAA;AACA,MAAIC,CAAC,GAAL,CAAA;;AACA,SAAOA,CAAC,GAAGC,aAAa,CAAxB,MAAA,EAAiC;AAC/BF,IAAAA,CAAC,IAADA,EAAAA;AACAA,IAAAA,CAAC,IAAIZ,OAAO,CAAPA,OAAAA,CAAgBc,aAAa,CAAlCF,CAAkC,CAA7BZ,CAALY;AACAC,IAAAA,CAAC;AACF;;AACD,SAAA,CAAA;AACD;;AAED,OAAO,SAAA,oBAAA,CAAA,MAAA,EAAsC;AAC3C;AACAE,EAAAA,MAAM,GAAGA,MAAM,CAANA,KAAAA,CAATA,OAASA,CAATA;AACA,SAAO,CACL;AACAC,EAAAA,QAAQ,CAACD,MAAM,CAFV,CAEU,CAAP,CAFH,EAGL;AACAE,EAAAA,qBAAqB,CAACF,MAAM,CAANA,CAAM,CAANA,CAJxB,IAIwBA,EAAD,CAJhB,CAAP;AAMD","sourcesContent":["// Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\r\nconst LETTERS = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\r\n\r\nexport function calculateDimensions (cells) {\r\n  const comparator = (a, b) => a - b\r\n  const allRows = cells.map(cell => cell.row).sort(comparator)\r\n  const allCols = cells.map(cell => cell.column).sort(comparator)\r\n  const minRow = allRows[0]\r\n  const maxRow = allRows[allRows.length - 1]\r\n  const minCol = allCols[0]\r\n  const maxCol = allCols[allCols.length - 1]\r\n\r\n  return [\r\n    { row: minRow, column: minCol },\r\n    { row: maxRow, column: maxCol }\r\n  ]\r\n}\r\n\r\nfunction columnLettersToNumber(columnLetters) {\r\n  // `for ... of ...` would require Babel polyfill for iterating a string.\r\n  let n = 0\r\n  let i = 0\r\n  while (i < columnLetters.length) {\r\n    n *= 26\r\n    n += LETTERS.indexOf(columnLetters[i])\r\n    i++\r\n  }\r\n  return n\r\n}\r\n\r\nexport function parseCellCoordinates(coords) {\r\n  // Examples: \"AA2091\", \"R988\", \"B1\"\r\n  coords = coords.split(/(\\d+)/)\r\n  return [\r\n    // Row.\r\n    parseInt(coords[1]),\r\n    // Column.\r\n    columnLettersToNumber(coords[0].trim())\r\n  ]\r\n}"]},"metadata":{},"sourceType":"module"}